# Введение

Язык Leo - это учебный транслируемый язык программирования, который может быть использован для несложных линейных
программ с числовыми и логическим типом данных.

По визуальной оценке, язык заимствует синтаксические конструкции из языков Pascal и c++

Язык Leo является транслируемым, но также поддерживает исполнение на уровне python объектов AST, что будет
приблизительно в 330 раз медленнее

Транслируется Leo умеет в Python и c++, при трансляции в Python поддерживает моментальное исполнение, а в случае c++
придётся передавать программу компилятору c++, например g++

Так, как язык поддерживает 2 числовых и 1 логический тип, это не язык общего назначения, однако на нём возможно
реализовать расчётные программы, пример такой программы приведёт
в [Сравнение производительности](./Perfomance_compare.md)

# Грамматика

```
# Базовые грамматические правила языка

<буква> :: =    a |
                b |
                c |
                d |
                e |
                f |
                g |
                h |
                i |
                j |
                k |
                l |
                m |
                n |
                o |
                p |
                q |
                r |
                s |
                t |
                u |
                v |
                w |
                x |
                y |
                z |
                A |
                B |
                C |
                D |
                E |
                F |
                G |
                H |
                I |
                J |
                K |
                L |
                M |
                N |
                O |
                P |
                Q |
                R |
                S |
                T |
                U |
                V |
                W |
                X |
                Y |
                Z

<цифра> ::= 0 |
            1 |
            2 |
            3 |
            4 |
            5 |
            6 |
            7 |
            8 |
            9

<идентификатор> ::= <буква> { <буква> | <цифра> }

<число>::=  <целое> |
            <действительное>

<целое>::=  <двоичное> |
            <восьмеричное> |
            <десятичное> |
            <шестнадцатеричное>

<двоичное>::= {/ 0 | 1 /} (B | b)

<восьмеричное>::= {/ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 /} (O | o)

<десятичное>::= {/ <цифра> /} [D | d]

<шестнадцатеричное>::= <цифра> {<цифра> | A | B | C | D | E | F | a | b | c | d | e | f} (H | h)

<действительное>::= <числовая_строка> <порядок> |
                    [<числовая_строка>] . <числовая_строка> [порядок]

<числовая_строка>::= {/ <цифра> /}

<порядок>::= (E | e)[+ | -] <числовая_строка>

<выражение> ::= <сумма> {<операции_группы_отношения> <сумма>}

<сумма> ::= <произведение> { <операции_группы_сложения> <произведение>}

<произведение> ::= <множитель> { <операции_группы_умножения> <множитель>}

<множитель> ::= <идентификатор> |
                <число> |
                <логическая_константа> |
                <унарная_операция> <множитель> |
                '(' <выражение> ')'

<логическая_константа>:: = true |
                           false


<операции_группы_отношения>::=  != |
                                == |
                                < |
                                <= |
                                > |
                                >=

<операции_группы_сложения>::=   + |
                                - |
                                ||

<операции_группы_умножения>::=  * |
                                / |
                                &&

<унарная_операция>::= !


<программа>::= '{' {/ (<описание> | <оператор>) ; /} '}'

<описание>::= <тип> <идентификатор> { , <идентификатор> }

<тип>::= int | float | bool

<оператор>::=   <составной> |
                <присваивания> |
                <условный> |
                <фиксированного_цикла> |
                <условного_цикла> |
                <ввода> |
                <вывода>

<составной>::= begin <оператор> { ; <оператор> } end

<присваивания>::= <идентификатор> := <выражение>

<условный>::= if '(' <выражение> ')' <оператор> [else <оператор>]

<фиксированного_цикла>::= for <присваивания> to <выражение> [step <выражение>] <оператор> next

<условного_цикла>::= while «(»<выражение> «)» <оператор>

<ввода>::= readln идентификатор {, <идентификатор> }

<вывода>::= writeln <выражение> {, <выражение> }
```

Также грамматика, за исключением различных видов чисел изображена с помощью диаграммы Вирта

![Диаграмма вирта](./grammar_txt/virt.png)

# Типы данных

В языке Leo 3 типа данных, далее указаны типы, соответствующие им на целевых языках

int - целочисленный (Python -> int, c++ -> long long), целое число, интервал зависит от целевого языка

float - вещественный (Python -> float, c++ -> double), вещественное число, интервал зависит от целевого языка

bool - логический (Python -> bool, c++ -> bool), поддерживает либо true, либо false

# Объявления и области видимости

Основная область видимости - глобальная, но также
для каждого счётчика цикла for создаётся **новая область видимости**, при этом счётчик доступен только для чтения

Каждый идентификатор, встречающийся в программе должен быть объявлен, за исключением счётчика в ***цикле for***

Объявление задаёт постоянные свойства объектов - поддерживаемые операции, о них далее

Использование переменной возможно только после её объявления

Пример объявления переменных

```
int i;
float number1, number2;
bool isPrime;
```

**В цикле for объявлять переменную не требуется**, смотрите в разделе `Оператор for`

# Выражения

Здесь будут приведены лишь языковые особенности выражений, так как по большей части они стандартны

Разделим операции на группы

## Арифметические:

```
+ - сложение
- - вычитание
* - умножение
/ - деление
```

Аргументом арифметических операций должен быть числовой тип (int | float)

Результатом арифметических операции является тип операндов операции (int + int) -> int

Типы операндов должны быть одинакового типа (float + int) -> ошибка

## Логические

```
|| - логическое или
&& - логическое и
```

Аргументом логических выражений должен быть логический тип (bool)

Результатом логических выражений также является логический тип

## Сравнения

```
== - равно
!= - не равно
< - меньше
<= - меньше или равно
> - больше
>= - больше или равно
```

Операции сравнения определены только для числовых типов, типы операндов также должны совпадать (float < int) -> ошибка

Результатом операций сравнения является логический тип

Таким образом можно построить сложные выражения, например

`121 / 11 * 11 == 121` - будет true, так как 121 делится на 11 без остатка

> Данное выражение представляет особый интерес и будет рассмотрено В разделе `Оптимизации`

## Операторы ввода/вывода

В языке 2 встроенных оператора ввода/вывода

readln - оператор ввода, автоматически преобразует ввод к типу переменной

writeln - оператор вывода

Примеры:

```
int x;
float y;
bool z;
readln x, y;
readln z;

writeln x;
writeln x == y, x == y && z, y;
```

## Оператор if

```
if (выражение типа bool)
    код, если выражение истинно
else
    код, если выражение ложно
```

Выражение должно иметь тип bool

## Оператор while

```
while (выражение типа bool)
    код, если выражение истинно
```

Выражение должно иметь тип bool

## Оператор for

```
for счётчик := выражение1 to выражение2 [step выражение3]
    код...
```

Пример:

```
for i := 0 to 5 + 5 step 1 + 2
```

Счётчик - переменная, которой присваивается начальное значение - выражение, в данном случае - счётчику **i**
присваивается **0**

Переменная-счётчик в операторе присваивания объявляется автоматически в новой области видимости с типом int, однако **не
должна быть объявлена заранее**. Это позволит транслировать как на python, так и на cpp без казусов и различий в
поведении
кода.

Также счётчик доступен **только для чтения**

После выхода из вложенности цикла for переменную-счётчик можно считать удалённой.

Выходит, что можно в двух циклах одинакового уровня вложенности использовать одно и то же название счётчика

```
for i := 0 to 10
...

for i := 10 to 20
...
```

выражение2 - цель, просчитывается каждый раз заново, то есть каждый раз будет выполнена бинарная операция 5 + 5

условием цикла является выражение (счётчик < выражение_после_to), то есть в данном случае - (i <= 5 + 5)

выражение3 - выражение, которое будет прибавлено к счётчику, то есть раскрывается как
i := i + (1 + 2) в данном случае, также каждый раз высчитывается заново

Все выражения в цикле for должны иметь тип int

Стоит упомянуть, что если необходимо, послднее значение счётчика можно вынести из цикла следующим образом

```
{
    int j;
    for i := 0 to 10
    begin
        writeln i;
        j := i
    end
    next;
    
    int i;
    i := j;
    writeln i;
}
```

### Трансляция в python

В python цикл for реализуется с использованием range

Конструкция будет иметь вид

```
for счётчик in range(выражение1, выражение2 + 1, выражение3):
    код...
```

### Трансляция в c++

В с++ цикл for будет иметь вид

```
for (long long счётчик = выражение1; счётчик <= выражение2, счётчик += выражение3)
{...}
```

## Комбинированный оператор

```
begin
оператор1;
оператор2;
оператор3
end;
```

Позволяет размещать несколько операторов в телах различных конструкций.
Последний оператор **не должен** заканчиваться символом ';'

## Оператор присваивания

```
идентификатор := выражение;
```

идентификатор должен быть объявлен

допустим для всех идентификаторов, кроме счётчика цикла for

выражение должно иметь тот же тип, что и переменная

## Комментарии

```
/*Комментарий*/
```

## Оптимизации

Язык ограничен своей грамматикой, поэтому следующие выражения будут заменены

### Деление нацело

Применимо только для типа int

Конструкция вида

```идентификатор1 / идентификатор2 * идентификатор2 == идентификатор1```

будет заменена на следующую

```идентификатор1 % идентификатор2 == 0```
